# 開発ガイドライン

## 🚨 重要: リファクタリング時の絶対ルール（システムプロンプト）

### リファクタリングの定義
リファクタリングとは、**外部から見た動作を一切変えずに**、内部のコード構造のみを改善することです。

### 絶対に守るべきルール
1. **機能の削除・変更は厳禁** - すべての機能を100%維持
2. **UIの変更は厳禁** - 見た目は1pxも変えない
3. **ルーティングの変更は厳禁** - URLパスを変えない
4. **ユーザー体験の変更は厳禁** - 操作感を一切変えない

### リファクタリングで許可される作業
- ✅ コードの整理・分割
- ✅ 重複コードの削減
- ✅ 変数名・関数名の改善
- ✅ コンポーネントの分離
- ✅ 型定義の追加・改善
- ✅ コメントの追加
- ✅ インポートの整理

### リファクタリング前のチェックリスト
- [ ] 現在の機能をすべてリストアップ
- [ ] バックアップを作成（git commit）
- [ ] 各ページのスクリーンショットを保存
- [ ] ルーティングパスを記録

### リファクタリング後の検証
- [ ] すべての機能が動作するか確認
- [ ] UIが変わっていないか目視確認
- [ ] すべてのルートにアクセスできるか確認
- [ ] ユーザーフローが変わっていないか確認

### 失敗例からの教訓
- `/map`、`/workout`、`/gym-friends`が誤って削除された事例
- 原因: リファクタリング時に「不要」と判断して削除
- 教訓: **機能の削除判断は絶対に行わない**

**このルールは最優先で遵守すること。違反した場合は即座に復元作業を行う。**

## Multi-AI協調開発システム (Claude Code x Zen MCP)

このプロジェクトでは、革新的なMulti-AI協調開発手法を導入しています。
- **Human**: 最終決定者・戦略的判断
- **Claude Code**: 実装・タスク実行
- **Zen MCP**: プロセス調整・ルーティング
- **Gemini MCP**: コードレベル技術調査
- **o3 MCP**: アーキテクチャ・設計レベル洞察

### Multi-AI協調ワークフロー
1. **壁打ち（相談）プロセスを必ず開始**
   - AIの提案を盲目的に受け入れない
   - 複数のAIモデルから多様な観点を取得
   - 人間が最終決定を行う

2. **タスク分散ルール**
   - **不可能な要求の解決**: Zen MCP → o3
   - **実装アプローチ検証**: Claude Code → Gemini
   - **技術調査**: Gemini MCP
   - **設計計画**: o3 MCP
   - **問題解決**: Zen MCP協調
   - **コードレビュー**: Gemini + Claude Code
   - **リスク評価**: o3 MCP

3. **品質保証プロセス**
   - 各AIモデルの強み・弱みを理解
   - 慎重なモデル選択とルーティング
   - 人間による監視と最終承認

### 🚨 Zen MCP使用タイミング（重要）
**以下の状況で自動的にZen MCPを活用する：**
1. **エラーが3回以上続く場合** → `mcp__zen__debug`で深い分析
2. **ビルドエラーが解決しない** → `mcp__zen__thinkdeep`で根本原因探索
3. **複雑な設計判断が必要** → `mcp__zen__consensus`で複数AI意見収集
4. **パフォーマンス問題** → `mcp__zen__analyze`でボトルネック特定
5. **セキュリティ懸念** → `mcp__zen__secaudit`で脆弱性チェック

**通常のタスクでは不要** - シンプルな実装や修正では使わない

### Zen MCP利用可能ツール
- チャット・深い思考・仮説挑戦
- 計画立案・コードレビュー・デバッグ
- リファクタリング・テスト生成

### 🚀 Gemini自動フォールバックシステム
**実装済み**: 5段階の自動モデル切り替え
1. **gemini-2.0-flash-lite** (30 RPM, 1M TPM, 200 RPD) - 最優先
2. **gemini-2.0-flash** (15 RPM, 1M TPM, 200 RPD)
3. **gemini-2.5-flash-lite** (15 RPM, 250k TPM, 1000 RPD)
4. **gemini-2.5-flash** (10 RPM, 250k TPM, 250 RPD)
5. **gemini-2.5-pro** (5 RPM, 250k TPM, 100 RPD) - 高品質

**使用量監視**: `./scripts/gemini-usage-monitor.sh`
- `limits`: モデル別制限表示
- `recommend`: フォールバック順序
- `test`: モデル動作テスト
- `log`: 使用履歴表示

**費用**: 通常使用なら**完全無料**（月1500リクエスト制限内）

## AIアシスタントツール統合
このプロジェクトでは、Claude Code、Zen MCP、Codex（Cursor）を統合使用しています。
どちらのツールを使用する場合も、以下のガイドラインに従ってください。

### 共通ルール
- **一貫性を保つ** - どのツールを使用しても同じコーディングスタイルとパターンを維持
- **コンテキスト共有** - 重要な変更や決定事項は`CLAUDE.md`に記録し、両ツール間で共有
- **相互補完** - 各ツールの強みを活かし、タスクに応じて適切に使い分ける
- **Multi-AI活用** - 複雑なタスクはZen MCPで複数AIを協調させて解決

### 開発環境の競合回避
**重要**: Claude CodeとCursorが同時に開発サーバーを起動すると競合が発生します。

#### 切り替え手順
1. **Claude Code → Cursor**:
   ```bash
   ./scripts/complete-reset.sh
   # Cursorでプロジェクトを開く
   # Cursorターミナルで: npm run dev
   ```

2. **Cursor → Claude Code**:
   ```bash
   # Cursorターミナルで: npm run dev:kill
   # Claude Codeで: PORT=3001 npm run dev
   ```

#### ポート管理
- **Claude Code**: 3001番ポートを使用 (`PORT=3001 npm run dev`)
- **Cursor**: 3000番ポートを使用 (デフォルト)
- **プロセス確認**: `ps aux | grep -E "(node|npm|next)" | grep -v grep`

## 🚀 デプロイメント完全ガイド

### 必須: Vercel環境変数設定
**すべてのVercelプロジェクトで必須**:
1. **NEXT_PUBLIC_SUPABASE_URL**: `https://htytewqvkgwyuvcsvjwm.supabase.co`
2. **NEXT_PUBLIC_SUPABASE_ANON_KEY**: 必須（Supabaseクライアント用）

### デプロイメント前チェックリスト
- [ ] 環境変数が正しく設定されている
- [ ] `npm run build` でローカルビルドが成功
- [ ] GitHub Actionsが正常実行
- [ ] Vercelデプロイメントが `Ready` 状態

### よくあるエラーと解決法
1. **"supabaseUrl is required"** → Vercel環境変数を確認・設定
2. **"Dependencies lock file not found"** → `.github/workflows/e2e.yml`の`cache-dependency-path`を修正
3. **"Xcode license agreements"** → `sudo xcodebuild -license` で解決

### 緊急時対応
```bash
# 1. 環境変数確認（Vercelダッシュボード）
# 2. 強制デプロイ
git add -A && git commit -m "Fix deployment" && git push
# 3. Vercel手動Redeploy
```

### 参考文書
- `gymtopia-app/DEPLOYMENT.md`: 基本的なデプロイ手順
- `gymtopia-app/TROUBLESHOOTING.md`: 問題解決ガイド
- `gymtopia-app/MIGRATION_PLAN.md`: プロジェクト移行記録

### Claude Code拡張ツール

#### 1. ccusage - 使用状況分析
**インストール済み**: `npm install -g ccusage`

```bash
# 日次レポート（デフォルト）
ccusage

# 月次集計
ccusage monthly

# セッション別使用量
ccusage session

# 5時間の課金ウィンドウ
ccusage blocks
```

**主な機能**:
- リアルタイム使用量モニタリング
- モデル別トラッキング（Opus、Sonnet）
- コスト計算（USD）
- キャッシュ使用量の可視化

#### 2. ccexp - 設定ファイル管理
**インストール済み**: `npm install -g ccexp`

```bash
# Claude Code設定とコマンドを探索
ccexp

# 特定ディレクトリをスキャン
ccexp -p /path/to/project
```

**主な機能**:
- CLAUDE.mdとスラッシュコマンドの管理
- インタラクティブなターミナルUI
- 設定ファイルのプレビューと編集

#### 3. ccpm - プロジェクト管理
**インストール済み**: `.claude-ccpm/`にコマンド配置

**主な機能**:
- GitHub Issuesとの連携
- Git worktreeを使った並列エージェント実行
- PRDからタスクへの自動変換
- 完全な監査証跡

#### 4. CCPlugins - カスタムコマンド
**インストール済み**: `~/.claude/commands/`に配置

**主な機能**:
- 24の専門的なコマンドセット
- 週2-3時間の作業時間短縮
- エンタープライズグレードの開発ワークフロー
- `/`コマンドでアクセス可能

#### 5. claude-code-log - 会話履歴ビューア
**インストール済み**: `pip3 install claude-code-log`

```bash
# 全プロジェクトの履歴をHTML化
claude-code-log --all-projects --open-browser

# インタラクティブTUIで閲覧
claude-code-log --tui

# 特定期間のログを抽出
claude-code-log --from-date "yesterday" --to-date "today"
```

**主な機能**:
- JSONL形式のログをHTMLに変換
- プロジェクト別の会話履歴管理
- トークン使用量の可視化
- タイムライン表示とフィルタリング

## 哲学

### 核となる信念
- **大きな変更より段階的な進歩** - コンパイルが通りテストに合格する小さな変更を行う
- **既存コードから学ぶ** - 実装前に研究し計画する
- **独断的より実用的** - プロジェクトの現実に適応する
- **巧妙なコードより明確な意図** - 退屈で明白なコードを書く

### シンプルさとは
- 関数/クラスごとに単一の責任
- 早すぎる抽象化を避ける
- 巧妙なトリックは使わない - 退屈な解決策を選ぶ
- 説明が必要なら、それは複雑すぎる

## プロセス

### 1. 計画とステージング
複雑な作業を3-5段階に分割。`IMPLEMENTATION_PLAN.md`に文書化：

```md
## ステージ N: [名前]
**目標**: [具体的な成果物]
**成功基準**: [テスト可能な結果]
**テスト**: [具体的なテストケース]
**ステータス**: [未開始|進行中|完了]
```

- 進捗に応じてステータスを更新
- すべてのステージが完了したらファイルを削除

### 2. 実装フロー
1. **理解** - コードベースの既存パターンを研究
2. **テスト** - 最初にテストを書く（レッド）
3. **実装** - テストをパスする最小限のコード（グリーン）
4. **リファクタリング** - テストをパスした状態でクリーンアップ
5. **コミット** - 計画にリンクした明確なメッセージで

### 3. 行き詰まったとき（3回試行後）
**重要**: 問題ごとに最大3回の試行、その後停止。

1. **失敗したことを文書化**：
   - 試したこと
   - 具体的なエラーメッセージ
   - 失敗したと思う理由

2. **代替案を調査**：
   - 2-3の類似実装を見つける
   - 使用された異なるアプローチをメモ

3. **基本を問い直す**：
   - これは正しい抽象化レベルか？
   - これを小さな問題に分割できるか？
   - 完全により簡単なアプローチはあるか？

4. **異なる角度から試す**：
   - 異なるライブラリ/フレームワーク機能？

## データベース設計ガイドライン（Supabase）

### ハードコーディングを避ける原則
- **環境変数の活用** - Supabase URLとAnonキーは必ず環境変数で管理
- **定数化** - テーブル名、カラム名、エラーメッセージは定数として定義
- **型定義** - データベースのスキーマに対応する型を明確に定義
- **抽象化** - データベース操作は再利用可能な関数/クラスとして実装

### 実装ルール
1. **接続情報**：
   - `.env`ファイルでSupabase URLとキーを管理
   - 本番/開発環境で異なる設定を可能に

2. **クエリ実装**：
   - SQLクエリの直書きを避ける
   - Supabaseクライアントのメソッドチェーンを活用
   - 共通操作は汎用関数として実装

3. **エラーハンドリング**：
   - データベース操作は必ずtry-catchで囲む
   - エラーメッセージは定数化
   - ユーザーフレンドリーなエラーメッセージを返す

4. **型安全性**：
   - TypeScriptの型定義を最大限活用
   - Supabaseの自動生成型を使用
   - 実行時の型チェックも実装

## 🏷️ バージョン管理システム（厳格運用）

### 現在のメジャーバージョン基準
**現在**: `v4.0.0` から開始（2025年9月23日時点）

### セマンティックバージョニング厳格ルール
```
v[MAJOR].[MINOR].[PATCH]
```

#### MAJOR（メジャー）バージョン - 破壊的変更
- **データベーススキーマの大幅変更**
- **APIの非互換変更**
- **ユーザーフローの根本的変更**
- **アーキテクチャの大幅見直し**

#### MINOR（マイナー）バージョン - 機能追加
- **新機能の追加**（検索機能、ジム登録など）
- **新しいページ・コンポーネントの追加**
- **APIエンドポイントの追加**
- **UIの大幅改善**

#### PATCH（パッチ）バージョン - バグ修正・小改善
- **バグ修正**
- **UI微調整**（色、レイアウト調整）
- **パフォーマンス改善**
- **リファクタリング**
- **ドキュメント更新**

### バージョン管理の絶対ルール

#### 1. 順次採番の厳守
- **絶対に過去のバージョンを超えない**
- **必ず現在の最新バージョンから+1**
- **飛び番は厳禁**

#### 2. タグ作成前の確認事項
```bash
# 1. 現在の最新タグを確認
git tag -l --sort=-version:refname | head -5

# 2. 次のバージョン番号を決定
# 最新が v4.1.2 なら
# - PATCH: v4.1.3
# - MINOR: v4.2.0
# - MAJOR: v5.0.0

# 3. タグ作成
git tag -a v4.1.3 -m "v4.1.3: [変更内容の説明]"
```

#### 3. バージョン決定フローチャート
```
変更内容は？
├─ 破壊的変更？ → MAJOR（v5.0.0）
├─ 新機能追加？ → MINOR（v4.2.0）
└─ バグ修正・改善？ → PATCH（v4.1.3）
```

### バックアップ実行ルール
**重要**: ユーザーから「バックアップして」と言われたら、必ず以下を実行：

1. **現在の最新バージョンを確認**：
   ```bash
   git tag -l --sort=-version:refname | head -1
   ```

2. **適切な次バージョンを決定**：
   - 変更内容に基づいてMAJOR/MINOR/PATCHを判断
   - 必ず順次採番

3. **即座にGitHubへプッシュ**：
   ```bash
   git add -A
   git commit -m "🔄 v[X.Y.Z]: [変更内容の説明]"
   git push origin main
   ```

4. **バージョンタグを作成**：
   ```bash
   git tag -a v[X.Y.Z] -m "v[X.Y.Z]: [詳細な説明]"
   git push origin --tags
   ```

### バックアップ時の自動実行項目
```bash
# 1. 全変更をステージング
git add -A

# 2. コミット
git commit -m "バックアップ: v[バージョン] - [説明]"

# 3. GitHubへプッシュ
git push origin main

# 4. タグ作成
git tag -a v[バージョン] -m "[タグの説明]"

# 5. タグをプッシュ
git push origin --tags
```

### Vercelデプロイメント
- GitHubへのプッシュで自動デプロイ
- 環境変数はVercelダッシュボードで管理
- デプロイ後は必ず本番環境で動作確認