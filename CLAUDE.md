# 開発ガイドライン

## Multi-AI協調開発システム (Claude Code x Zen MCP)

このプロジェクトでは、革新的なMulti-AI協調開発手法を導入しています。
- **Human**: 最終決定者・戦略的判断
- **Claude Code**: 実装・タスク実行
- **Zen MCP**: プロセス調整・ルーティング
- **Gemini MCP**: コードレベル技術調査
- **o3 MCP**: アーキテクチャ・設計レベル洞察

### Multi-AI協調ワークフロー
1. **壁打ち（相談）プロセスを必ず開始**
   - AIの提案を盲目的に受け入れない
   - 複数のAIモデルから多様な観点を取得
   - 人間が最終決定を行う

2. **タスク分散ルール**
   - **不可能な要求の解決**: Zen MCP → o3
   - **実装アプローチ検証**: Claude Code → Gemini
   - **技術調査**: Gemini MCP
   - **設計計画**: o3 MCP
   - **問題解決**: Zen MCP協調
   - **コードレビュー**: Gemini + Claude Code
   - **リスク評価**: o3 MCP

3. **品質保証プロセス**
   - 各AIモデルの強み・弱みを理解
   - 慎重なモデル選択とルーティング
   - 人間による監視と最終承認

### Zen MCP利用可能ツール
- チャット・深い思考・仮説挑戦
- 計画立案・コードレビュー・デバッグ
- リファクタリング・テスト生成

## AIアシスタントツール統合
このプロジェクトでは、Claude Code、Zen MCP、Codex（Cursor）を統合使用しています。
どちらのツールを使用する場合も、以下のガイドラインに従ってください。

### 共通ルール
- **一貫性を保つ** - どのツールを使用しても同じコーディングスタイルとパターンを維持
- **コンテキスト共有** - 重要な変更や決定事項は`CLAUDE.md`に記録し、両ツール間で共有
- **相互補完** - 各ツールの強みを活かし、タスクに応じて適切に使い分ける
- **Multi-AI活用** - 複雑なタスクはZen MCPで複数AIを協調させて解決

### 開発環境の競合回避
**重要**: Claude CodeとCursorが同時に開発サーバーを起動すると競合が発生します。

#### 切り替え手順
1. **Claude Code → Cursor**:
   ```bash
   ./scripts/complete-reset.sh
   # Cursorでプロジェクトを開く
   # Cursorターミナルで: npm run dev
   ```

2. **Cursor → Claude Code**:
   ```bash
   # Cursorターミナルで: npm run dev:kill
   # Claude Codeで: PORT=3001 npm run dev
   ```

#### ポート管理
- **Claude Code**: 3001番ポートを使用 (`PORT=3001 npm run dev`)
- **Cursor**: 3000番ポートを使用 (デフォルト)
- **プロセス確認**: `ps aux | grep -E "(node|npm|next)" | grep -v grep`

## 🚀 デプロイメント完全ガイド

### 必須: Vercel環境変数設定
**すべてのVercelプロジェクトで必須**:
1. **NEXT_PUBLIC_SUPABASE_URL**: `https://htytewqvkgwyuvcsvjwm.supabase.co`
2. **NEXT_PUBLIC_SUPABASE_ANON_KEY**: 必須（Supabaseクライアント用）

### デプロイメント前チェックリスト
- [ ] 環境変数が正しく設定されている
- [ ] `npm run build` でローカルビルドが成功
- [ ] GitHub Actionsが正常実行
- [ ] Vercelデプロイメントが `Ready` 状態

### よくあるエラーと解決法
1. **"supabaseUrl is required"** → Vercel環境変数を確認・設定
2. **"Dependencies lock file not found"** → `.github/workflows/e2e.yml`の`cache-dependency-path`を修正
3. **"Xcode license agreements"** → `sudo xcodebuild -license` で解決

### 緊急時対応
```bash
# 1. 環境変数確認（Vercelダッシュボード）
# 2. 強制デプロイ
git add -A && git commit -m "Fix deployment" && git push
# 3. Vercel手動Redeploy
```

### 参考文書
- `gymtopia-app/DEPLOYMENT.md`: 基本的なデプロイ手順
- `gymtopia-app/TROUBLESHOOTING.md`: 問題解決ガイド
- `gymtopia-app/MIGRATION_PLAN.md`: プロジェクト移行記録

### Claude Code拡張ツール

#### 1. ccusage - 使用状況分析
**インストール済み**: `npm install -g ccusage`

```bash
# 日次レポート（デフォルト）
ccusage

# 月次集計
ccusage monthly

# セッション別使用量
ccusage session

# 5時間の課金ウィンドウ
ccusage blocks
```

**主な機能**:
- リアルタイム使用量モニタリング
- モデル別トラッキング（Opus、Sonnet）
- コスト計算（USD）
- キャッシュ使用量の可視化

#### 2. ccexp - 設定ファイル管理
**インストール済み**: `npm install -g ccexp`

```bash
# Claude Code設定とコマンドを探索
ccexp

# 特定ディレクトリをスキャン
ccexp -p /path/to/project
```

**主な機能**:
- CLAUDE.mdとスラッシュコマンドの管理
- インタラクティブなターミナルUI
- 設定ファイルのプレビューと編集

#### 3. ccpm - プロジェクト管理
**インストール済み**: `.claude-ccpm/`にコマンド配置

**主な機能**:
- GitHub Issuesとの連携
- Git worktreeを使った並列エージェント実行
- PRDからタスクへの自動変換
- 完全な監査証跡

#### 4. CCPlugins - カスタムコマンド
**インストール済み**: `~/.claude/commands/`に配置

**主な機能**:
- 24の専門的なコマンドセット
- 週2-3時間の作業時間短縮
- エンタープライズグレードの開発ワークフロー
- `/`コマンドでアクセス可能

#### 5. claude-code-log - 会話履歴ビューア
**インストール済み**: `pip3 install claude-code-log`

```bash
# 全プロジェクトの履歴をHTML化
claude-code-log --all-projects --open-browser

# インタラクティブTUIで閲覧
claude-code-log --tui

# 特定期間のログを抽出
claude-code-log --from-date "yesterday" --to-date "today"
```

**主な機能**:
- JSONL形式のログをHTMLに変換
- プロジェクト別の会話履歴管理
- トークン使用量の可視化
- タイムライン表示とフィルタリング

## 哲学

### 核となる信念
- **大きな変更より段階的な進歩** - コンパイルが通りテストに合格する小さな変更を行う
- **既存コードから学ぶ** - 実装前に研究し計画する
- **独断的より実用的** - プロジェクトの現実に適応する
- **巧妙なコードより明確な意図** - 退屈で明白なコードを書く

### シンプルさとは
- 関数/クラスごとに単一の責任
- 早すぎる抽象化を避ける
- 巧妙なトリックは使わない - 退屈な解決策を選ぶ
- 説明が必要なら、それは複雑すぎる

## プロセス

### 1. 計画とステージング
複雑な作業を3-5段階に分割。`IMPLEMENTATION_PLAN.md`に文書化：

```md
## ステージ N: [名前]
**目標**: [具体的な成果物]
**成功基準**: [テスト可能な結果]
**テスト**: [具体的なテストケース]
**ステータス**: [未開始|進行中|完了]
```

- 進捗に応じてステータスを更新
- すべてのステージが完了したらファイルを削除

### 2. 実装フロー
1. **理解** - コードベースの既存パターンを研究
2. **テスト** - 最初にテストを書く（レッド）
3. **実装** - テストをパスする最小限のコード（グリーン）
4. **リファクタリング** - テストをパスした状態でクリーンアップ
5. **コミット** - 計画にリンクした明確なメッセージで

### 3. 行き詰まったとき（3回試行後）
**重要**: 問題ごとに最大3回の試行、その後停止。

1. **失敗したことを文書化**：
   - 試したこと
   - 具体的なエラーメッセージ
   - 失敗したと思う理由

2. **代替案を調査**：
   - 2-3の類似実装を見つける
   - 使用された異なるアプローチをメモ

3. **基本を問い直す**：
   - これは正しい抽象化レベルか？
   - これを小さな問題に分割できるか？
   - 完全により簡単なアプローチはあるか？

4. **異なる角度から試す**：
   - 異なるライブラリ/フレームワーク機能？

## データベース設計ガイドライン（Supabase）

### ハードコーディングを避ける原則
- **環境変数の活用** - Supabase URLとAnonキーは必ず環境変数で管理
- **定数化** - テーブル名、カラム名、エラーメッセージは定数として定義
- **型定義** - データベースのスキーマに対応する型を明確に定義
- **抽象化** - データベース操作は再利用可能な関数/クラスとして実装

### 実装ルール
1. **接続情報**：
   - `.env`ファイルでSupabase URLとキーを管理
   - 本番/開発環境で異なる設定を可能に

2. **クエリ実装**：
   - SQLクエリの直書きを避ける
   - Supabaseクライアントのメソッドチェーンを活用
   - 共通操作は汎用関数として実装

3. **エラーハンドリング**：
   - データベース操作は必ずtry-catchで囲む
   - エラーメッセージは定数化
   - ユーザーフレンドリーなエラーメッセージを返す

4. **型安全性**：
   - TypeScriptの型定義を最大限活用
   - Supabaseの自動生成型を使用
   - 実行時の型チェックも実装

## バックアップ管理

### バックアップ実行ルール
**重要**: ユーザーから「バックアップして」と言われたら、必ず以下を実行：

1. **即座にGitHubへプッシュ**：
   ```bash
   git add -A
   git commit -m "バックアップ: [変更内容の説明]"
   git push origin main
   ```

2. **バージョンタグを作成**：
   ```bash
   # セマンティックバージョニングでタグ付け
   git tag -a v[major].[minor].[patch] -m "バックアップ: [バージョンの説明]"
   git push origin --tags
   ```

3. **タグ付けルール**：
   - **v1.0.0** - メジャーリリース（大きな機能追加・変更）
   - **v1.1.0** - マイナーリリース（機能追加）
   - **v1.1.1** - パッチリリース（バグ修正・小さな改善）

### バックアップ時の自動実行項目
```bash
# 1. 全変更をステージング
git add -A

# 2. コミット
git commit -m "バックアップ: v[バージョン] - [説明]"

# 3. GitHubへプッシュ
git push origin main

# 4. タグ作成
git tag -a v[バージョン] -m "[タグの説明]"

# 5. タグをプッシュ
git push origin --tags
```

### Vercelデプロイメント
- GitHubへのプッシュで自動デプロイ
- 環境変数はVercelダッシュボードで管理
- デプロイ後は必ず本番環境で動作確認